from tfccs.utils import (read_fextract, is_good_fextract_row, read_rows_of_indices)
from argparse import ArgumentParser
import numpy as np
import sys
import os.path as op
import logging

FORMATTER = op.basename(__file__) + ':%(levelname)s:'+'%(message)s'
logging.basicConfig(level=logging.DEBUG, format=FORMATTER)
log = logging.getLogger(__name__)

desc = """Sample unique CCS bases from classes below proportionally (x, y, z):
1) erronous CCS bases which maps to reference as Insertion, Substitution or PreviousIsDeletion.
2) non-errornous CCS bases which maps to reference as SequenceMatch and not PreviousIsDeletion, from the same CCS read that have errornous CCS bases.
3) non-errornous CCS bases which maps to reference as SequenceMatch and not PreviousIsDeletion, from random CCS reads.
"""


def filter_and_sample_from_files(filename_filterf_numbases_list, include_header=True):
    """
    filename_filterf_numbases_list --- contains a list of (filename, filter_function, num_bases)
    Each input filename must be a fextract.csv file, apply filter_function to remove un-qualified
    bases first, then from the qualified bases, select num_bases rows and return.
    Note that if include_header is True, include it as the very first row in output
    """
    np.random.seed(0)
    if len(filename_filterf_numbases_list) == 0:
        raise ValueError("Input is empty!")

    indices = []  # indices of rows (not including header) to sample
    rows = []  # selected (sampled) rows to return
    header = None
    for index, (filename, filter_f, num_bases) in enumerate(filename_filterf_numbases_list):
        good_row_indices = read_fextract(filename, is_good_fextract_row_f=filter_f, return_index=True)
        n_good_rows = len(good_row_indices)
        log.info(f"Sampling {num_bases} bases from a total of {n_good_rows} qualified bases in file {filename}.")
        if n_good_rows < num_bases:
            num_bases = n_good_rows
            log.info(
                f"Wanted to sample {num_bases} rows from file {filename}" +
                f", however file contains only {n_good_rows} good rows excluding header!")

        n_choose_k = np.random.choice(good_row_indices, num_bases)
        downsample_row_indices_count_header = [r + 1 for r in n_choose_k]
        if index == 0 and include_header is True:
            header = read_rows_of_indices(filename, [0])
        rows = read_rows_of_indices(filename, downsample_row_indices_count_header)

    np.random.shuffle(rows)
    return header + rows


def run(args):
    ferror = args.in_error_rich_fextract
    frandom = args.in_random_fextract
    total_bases = args.total_bases
    x, y, z = args.x, args.y, args.z
    out_csv = args.out_csv
    if x + y + z != 100:
        raise ValueError(f"Sum of ({x}, {y}, {z}) must equal 100!")
    if total_bases <= 0:
        raise ValueError("Invalid total number of bases to sample!")
    nx, ny, nz = total_bases * x // 100, total_bases * y // 100, total_bases * z // 100

    def is_error(record):
        ins_sub = is_good_fextract_row(record, min_dist2end=100, allowed_strands="F",
                                       allowed_ccs2genome_cigars="IX", require_previous_is_deletion=False)
        prev_del = is_good_fextract_row(record, min_dist2end=100, allowed_strands="F",
                                        allowed_ccs2genome_cigars="=", require_previous_is_deletion=True)
        return ins_sub or prev_del

    def is_not_error(record):
        return not is_error(record)

    filename_filterf_numbases_list = [
        (ferror, is_error, nx),
        (ferror, is_not_error, ny),
        (frandom, is_not_error, nz)
    ]

    out_rows = filter_and_sample_from_files(filename_filterf_numbases_list, include_header=True)
    with open(out_csv, 'w') as writer:
        for r in out_rows:
            writer.write(r)
    return 0


def get_parser():
    """Set up and return argument parser."""
    p = ArgumentParser(desc)
    p.add_argument("in_error_rich_fextract", help="Input error-rich fextract csv file, generated by 'fextract -r 1'.")
    p.add_argument("in_random_fextract",
                   help="Input not error-rich random fextract csv file, generated by 'fextract -r 0 --max-bases-per-1kbp 2")
    p.add_argument("total_bases", type=int, help="Maximum number of bases to sample")
    p.add_argument("x", type=int, help="Proportion of class (1) bases to sample, e.g. x=50 meaning 50 percent")
    p.add_argument("y", type=int, help="Proportion of class (2) bases to sample, e.g. y=10 meaning 10 percent")
    p.add_argument("z", type=int, help="Proportion of class (3) bases to sample, e.g. z=40 meaning 40 percent")
    p.add_argument("out_csv", help="Output fextract csv containing sampled records")
    return p


def main(args=sys.argv[1:]):
    """main"""
    log.info(f'args: {args}')
    return run(get_parser().parse_args(args))


if __name__ == "__main__":
    sys.exit(main(args=sys.argv[1:]))
